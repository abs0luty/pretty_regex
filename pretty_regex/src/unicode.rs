use crate::{CharClass, PrettyRegex, Standard};

pub enum Script {
    Common,
    Arabic,
    Armenian,
    Bengali,
    Bopomofo,
    Braille,
    Buhid,
    CandianAboriginal,
    Cherokee,
    Cyrillic,
    Devanagari,
    Ethiopic,
    Georgian,
    Greek,
    Gujarati,
    Gurkmukhi,
    Han,
    Hangul,
    Hanunoo,
    Hebrew,
    Hirigana,
    Inherited,
    Kannada,
    Katakana,
    Khmer,
    Lao,
    Latin,
    Limbu,
    Malayalam,
    Mongolian,
    Myanmar,
    Ogham,
    Oriya,
    Runic,
    Sinhala,
    Syriac,
    Tagalog,
    Tagbanwa,
    TaiLe,
    Tamil,
    Telugu,
    Thaana,
    Thai,
    Tibetan,
    Yi,
}

impl Script {
    pub fn to_regex(self) -> PrettyRegex<CharClass<Standard>> {
        PrettyRegex::from(match self {
            Self::Common => r"\p{Common}",
            Self::Arabic => r"\p{Arabic}",
            Self::Armenian => r"\p{Armenian}",
            Self::Bengali => r"\p{Bengali}",
            Self::Bopomofo => r"\p{Bopomofo}",
            Self::Braille => r"\p{Braille}",
            Self::Buhid => r"\p{Buhid}",
            Self::CandianAboriginal => r"\p{CandianAboriginal}",
            Self::Cherokee => r"\p{Cherokee}",
            Self::Cyrillic => r"\p{Cyrillic}",
            Self::Devanagari => r"\p{Devanagari}",
            Self::Ethiopic => r"\p{Ethiopic}",
            Self::Georgian => r"\p{Georgian}",
            Self::Greek => r"\p{Greek}",
            Self::Gujarati => r"\p{Gujarati}",
            Self::Gurkmukhi => r"\p{Gurkmukhi}",
            Self::Han => r"\p{Han}",
            Self::Hangul => r"\p{Hangul}",
            Self::Hanunoo => r"\p{Hanunoo}",
            Self::Hebrew => r"\p{Hebrew}",
            Self::Hirigana => r"\p{Hirigana}",
            Self::Inherited => r"\p{Inherited}",
            Self::Kannada => r"\p{Kannada}",
            Self::Katakana => r"\p{Katakana}",
            Self::Khmer => r"\p{Khmer}",
            Self::Lao => r"\p{Lao}",
            Self::Latin => r"\p{Latin}",
            Self::Limbu => r"\p{Limbu}",
            Self::Malayalam => r"\p{Malayalam}",
            Self::Mongolian => r"\p{Mongolian}",
            Self::Myanmar => r"\p{Myanmar}",
            Self::Ogham => r"\p{Ogham}",
            Self::Oriya => r"\p{Oriya}",
            Self::Runic => r"\p{Runic}",
            Self::Sinhala => r"\p{Sinhala}",
            Self::Syriac => r"\p{Syriac}",
            Self::Tagalog => r"\p{Tagalog}",
            Self::Tagbanwa => r"\p{Tagbanwa}",
            Self::TaiLe => r"\p{TaiLe}",
            Self::Tamil => r"\p{Tamil}",
            Self::Telugu => r"\p{Telugu}",
            Self::Thaana => r"\p{Thaana}",
            Self::Thai => r"\p{Thai}",
            Self::Tibetan => r"\p{Tibetan}",
            Self::Yi => r"\p{Yi}",
        })
    }
}

impl From<Script> for PrettyRegex<CharClass<Standard>> {
    fn from(value: Script) -> Self {
        value.to_regex()
    }
}

pub enum Category {
    Letter,
    LowercaseLetter,
    UppercaseLetter,
    TitlecaseLetter,
    CasedLetter,
    ModifierLetter,
    OtherLetter,
    Mark,
    NonSpacingMark,
    SpaceCombiningMark,
    EnclosingMark,
    Separator,
    SpaceSeparator,
    LineSeparator,
    ParagraphSeparator,
    Symbol,
    MathSymbol,
    CurrencySymbol,
    ModifierSymbol,
    OtherSymbol,
    Number,
    DecimalDigitNumber,
    LetterNumber,
    OtherNumber,
    Punctuation,
    DashPunctuation,
    OpenPunctuation,
    ClosePunctuation,
    InitialPunctuation,
    FinalPunctuation,
    ConnectorPunctuation,
    OtherPunctuation,
    Other,
    Control,
    Format,
    PrivateUse,
    Surrogate,
    Unassigned,
}

impl Category {
    #[inline]
    #[must_use]
    pub fn to_regex(self) -> PrettyRegex<CharClass<Standard>> {
        PrettyRegex::from(match self {
            Self::Letter => r"\p{Letter}",
            Self::LowercaseLetter => r"\p{Lowercase_Letter}",
            Self::UppercaseLetter => r"\p{Uppercase_Letter}",
            Self::TitlecaseLetter => r"\p{Titlecase_Letter}",
            Self::CasedLetter => r"\p{Cased_Letter}",
            Self::ModifierLetter => r"\p{Modifier_Letter}",
            Self::OtherLetter => r"\p{Other_Letter}",
            Self::Mark => r"\p{Mark}",
            Self::NonSpacingMark => r"\p{NonSpacing_Mark}",
            Self::SpaceCombiningMark => r"\p{SpaceCombining_Mark}",
            Self::EnclosingMark => r"\p{Enclosing_Mark}",
            Self::Separator => r"\p{Separator}",
            Self::SpaceSeparator => r"\p{Space_Separator}",
            Self::LineSeparator => r"\p{Line_Separator}",
            Self::ParagraphSeparator => r"\p{Paragraph_Separator}",
            Self::Symbol => r"\p{Symbol}",
            Self::MathSymbol => r"\p{Math_Symbol}",
            Self::CurrencySymbol => r"\p{Currency_Symbol}",
            Self::ModifierSymbol => r"\p{Modifier_Symbol}",
            Self::OtherSymbol => r"\p{Other_Symbol}",
            Self::Number => r"\p{Number}",
            Self::DecimalDigitNumber => r"\p{DecimalDigit_Number}",
            Self::LetterNumber => r"\p{Letter_Number}",
            Self::OtherNumber => r"\p{Other_Number}",
            Self::Punctuation => r"\p{Punctuation}",
            Self::DashPunctuation => r"\p{Dash_Punctuation}",
            Self::OpenPunctuation => r"\p{Open_Punctuation}",
            Self::ClosePunctuation => r"\p{Close_Punctuation}",
            Self::InitialPunctuation => r"\p{Initial_Punctuation}",
            Self::FinalPunctuation => r"\p{Final_Punctuation}",
            Self::ConnectorPunctuation => r"\p{Connector_Punctuation}",
            Self::OtherPunctuation => r"\p{Other_Punctuation}",
            Self::Other => r"\p{Other}",
            Self::Control => r"\p{Control}",
            Self::Format => r"\p{Format}",
            Self::PrivateUse => r"\p{Private_Use}",
            Self::Surrogate => r"\p{Surrogate}",
            Self::Unassigned => r"\p{Unassigned}",
        })
    }
}

impl From<Category> for PrettyRegex<CharClass<Standard>> {
    fn from(value: Category) -> Self {
        value.to_regex()
    }
}
